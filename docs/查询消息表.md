# 消息表查询指南

## 表名
**`messages`**

## 表结构

```sql
CREATE TABLE IF NOT EXISTS messages (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  message_id VARCHAR(36) UNIQUE NOT NULL,        -- 消息唯一ID
  conversation_id VARCHAR(100) NOT NULL,          -- 会话ID
  sender_id VARCHAR(36) NOT NULL,                 -- 发送者用户ID
  receiver_id VARCHAR(36) NOT NULL,               -- 接收者用户ID
  content TEXT NOT NULL,                          -- 消息内容
  message_type VARCHAR(20) NOT NULL,              -- 消息类型（TEXT, IMAGE, FILE, VOICE等）
  timestamp BIGINT NOT NULL,                       -- 时间戳（毫秒）
  status VARCHAR(20) DEFAULT 'SENT',              -- 消息状态（SENT, READ等）
  is_recalled BOOLEAN DEFAULT FALSE,              -- 是否已撤回
  recall_by VARCHAR(36),                          -- 撤回者用户ID
  recall_time BIGINT,                             -- 撤回时间戳
  extra TEXT,                                     -- 额外信息（JSON格式）
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- 创建时间
  INDEX idx_conversation (conversation_id),
  INDEX idx_message_id (message_id),
  INDEX idx_timestamp (timestamp),
  INDEX idx_sender (sender_id),
  INDEX idx_receiver (receiver_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
```

## 常用查询

### 1. 查询某个用户的所有消息（按时间倒序）
```sql
SELECT * FROM messages 
WHERE receiver_id = 'f0cefb04-f4b1-4a9d-b4fe-43896e571cc8' 
ORDER BY timestamp DESC 
LIMIT 20;
```

### 2. 查询某个会话的所有消息
```sql
SELECT * FROM messages 
WHERE conversation_id = 'conversation_id_here' 
ORDER BY timestamp ASC;
```

### 3. 查询某个用户未读的消息
```sql
SELECT m.* 
FROM messages m
LEFT JOIN message_read_status mrs ON m.message_id = mrs.message_id AND mrs.user_id = 'user_id_here'
WHERE m.receiver_id = 'user_id_here' 
AND mrs.message_id IS NULL
AND m.is_recalled = FALSE
ORDER BY m.timestamp DESC;
```

### 4. 查询某个时间点之后的消息（离线消息查询）
```sql
SELECT m.*, 
       CASE WHEN mrs.message_id IS NOT NULL THEN 1 ELSE 0 END as is_read
FROM messages m
LEFT JOIN message_read_status mrs ON m.message_id = mrs.message_id AND mrs.user_id = 'user_id_here'
WHERE m.receiver_id = 'user_id_here' 
AND m.timestamp > 0  -- 替换为 lastMessageTime
ORDER BY m.timestamp ASC
LIMIT 100;
```

### 5. 查询两个用户之间的所有消息
```sql
SELECT * FROM messages 
WHERE (sender_id = 'user_id_1' AND receiver_id = 'user_id_2')
   OR (sender_id = 'user_id_2' AND receiver_id = 'user_id_1')
ORDER BY timestamp ASC;
```

### 6. 统计某个用户的消息数量
```sql
SELECT COUNT(*) as message_count 
FROM messages 
WHERE receiver_id = 'user_id_here';
```

### 7. 查询最近发送的消息
```sql
SELECT * FROM messages 
WHERE sender_id = 'user_id_here' 
ORDER BY timestamp DESC 
LIMIT 10;
```

### 8. 查询已撤回的消息
```sql
SELECT * FROM messages 
WHERE is_recalled = TRUE 
ORDER BY recall_time DESC;
```

## 关联表

### message_read_status（消息已读状态表）
```sql
-- 查询消息已读状态
SELECT mrs.*, m.content, m.sender_id, m.receiver_id
FROM message_read_status mrs
JOIN messages m ON mrs.message_id = m.message_id
WHERE mrs.user_id = 'user_id_here';
```

## 注意事项

1. **时间戳字段**：`timestamp` 是 BIGINT 类型，存储的是毫秒级时间戳
2. **消息ID**：`message_id` 是 UUID 格式的字符串，是消息的唯一标识
3. **会话ID**：`conversation_id` 用于标识消息所属的会话
4. **索引**：表中有多个索引，查询时尽量使用索引字段（如 `receiver_id`, `timestamp`, `conversation_id`）

## 示例：查询当前用户的离线消息

假设用户ID是 `f0cefb04-f4b1-4a9d-b4fe-43896e571cc8`，查询所有未接收的消息：

```sql
SELECT m.*, 
       CASE WHEN mrs.message_id IS NOT NULL THEN 1 ELSE 0 END as is_read
FROM messages m
LEFT JOIN message_read_status mrs ON m.message_id = mrs.message_id 
  AND mrs.user_id = 'f0cefb04-f4b1-4a9d-b4fe-43896e571cc8'
WHERE m.receiver_id = 'f0cefb04-f4b1-4a9d-b4fe-43896e571cc8' 
AND m.timestamp > 0
AND m.is_recalled = FALSE
ORDER BY m.timestamp ASC
LIMIT 100;
```

